# Michaelis-Menten Kinetics; my specific data is used in the following code, and lines marked with '#/***/' signify lines you should interchange
# with your own data. Dimensional inconsistencies should not occur due to the generalized nature of the code but regardless are likely easy to tweak
# '4M' and 'ED' labels refer to the specific inhibitors I used, and can be changed wherever they occur with the appropriate inhibitor name

# import necessary packages
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
from scipy import optimize

# define function to be able to have line breaks in pandas dataframe (not necessary for plotting)
from IPython.display import display, HTML
def pretty_print(df):
    return display(HTML(df.to_html().replace("\\n","<br>")))


# organize calculated initial substrate conc.s & corresponding absorbance change rates (Abs/min; absolute value, originally neg. as proxy molecule NADPH was consumed in rxn)
# absorbance change rates calculated with spectrophotometer
concs = np.array([0, 2.5, 5.0, 7.5, 10.0, 20.0]) #/***/

abs_noI = np.array([0,.1107,.1173,.1421,.1565,.1639]) 
abs_4M = np.array([0,.0787,.0984,.1102,.1192,.1588])
abs_ED = np.array([0,.0622,.0885,.1029,.1039,.1112])


# necessary constants
# molar absorptivity constant of NADPH (used as proxy to measure Abs values)
epsil = 6.22

E_conc = 2.96 #stock enzyme conc. in micrograms/mL #/***/
I1_conc = 100 #stock 4MP conc. in mM; needed for K_I calculation below #/***/


# divide Abs change rates by molar absorptivity constant of NADPH to get initial velocity rates in mM/min
vel_noI = abs_noI/epsil
vel_4M = abs_4M/epsil
vel_ED = abs_ED/epsil

# prepare plots for MM graphs
fig, ax = plt.subplots(1,3)
plt.subplots_adjust(bottom=0, right=2.5, top=0.92)
plt.suptitle('Michaelis-Menten Graphs')
        
# build MM plots with base MM function and optimized values of Km & v_max based on scipy optimization of base function
MM_axis = np.arange(concs[0],concs[len(concs)-1],0.5)

def MM_func(s,v_m,K_m):
    v = (v_m*s)/(K_m+s)
    return(v)

def MM_plot(vel,plotnum,lab):
    y_axis = vel
    ax[plotnum].scatter(concs,y_axis,label='velocity')

    v_m,K_m = optimize.curve_fit(MM_func, xdata = concs, ydata = vel)[0]
    ax[plotnum].plot(MM_axis, MM_func(MM_axis,v_m,K_m), 'r', label=lab+': $v_0$ = '+str(np.round(v_m,2))+'[S] / ('+str(np.round(K_m,2))+'+[S])')
    ax[plotnum].legend(bbox_to_anchor=(0.9,0.3),loc='lower right',borderaxespad=0)
    
    return(v_m,K_m)

v_m1,K_m1 = MM_plot(vel_noI,0,'Uninhib.')
v_m2,K_m2 = MM_plot(vel_4M,1,'4MP')
v_m3,K_m3 = MM_plot(vel_ED,2,'EDTA')


# prepare plots for LB graphs
fig, ax = plt.subplots(1,2)
plt.subplots_adjust(bottom=0, right=2.5, top=0.93)
plt.suptitle('Lineweaver-Burke Graphs')

# build LB plots with similar base function & no need to optimize; Km & v_max values already calculated from MM plots
LB_axis = np.arange((1/concs[len(concs)-1])-0.6,1/concs[1],0.01)

def LB_func(x,v_m,K_m):
    #y,x = 1/v,1/s
    y = (K_m/v_m)*x + (1/v_m)
    return(y)

y_ax1 = np.linspace(-30,100,4)
x_ax0 = np.zeros((len(y_ax1),))

x_ax1 = LB_axis
y_ax0 = np.zeros((len(x_ax1),))
def LB_plot(v_m,K_m,plotnum,inhib):
   
    ax[plotnum].plot(LB_axis, LB_func(LB_axis,v_m1,K_m1), 'r', label='Uninhib.: 1/$v_0$ = ('+str(np.round((v_m1/K_m1),2))+'1/[S]) + '+str(np.round(1/v_m1,2)))
    ax[plotnum].plot(LB_axis, LB_func(LB_axis,v_m,K_m), 'b', label='Inhib by '+inhib+': 1/$v_0$ = ('+str(np.round((v_m/K_m),2))+'1/[S]) + '+str(np.round(1/v_m,2)))
    ax[plotnum].plot(x_ax0,y_ax1,'--k')
    ax[plotnum].plot(x_ax1,y_ax0,'--k')
    ax[plotnum].legend(bbox_to_anchor=(0.05,0.95),loc='upper left',borderaxespad=0)

LB_plot(v_m2,K_m2,0,'4MP')
LB_plot(v_m3,K_m3,1,'EDTA')

plt.show()

#display table to show organized data
df_rates = pd.DataFrame({
    "[substrate] \\n (mM)":concs,
    "rate_noI \\n (Abs/min)":abs_noI,
    "vel_noI \\n (mM/min)":vel_noI,
    "rate_4M \\n (Abs/min)":abs_4M,
    "vel_4M \\n (mM/min)":vel_4M,
    "rate_ED \\n (Abs/min)":abs_ED,
    "vel_ED \\n (mM/min)":vel_ED
})

pretty_print(df_rates)

# func to find k_cat, with conversion factors to make (mM mL/min microg) into 1/s & account for volume change from stock conc
def k_cat(v_m):
    k = (v_m/E_conc)*(42097/600)
    return(k)

# func to find K_I, with 0.1 for stock conc. change due to vol. change
def K_I(K_app,I_conc):
    k = 0.1*I_conc*(1/((K_app/K_m1)-1))
    return(k)

print('k_cat of YqhD w/ propionaldehyde: '+str(np.round(k_cat(v_m1),2))+' s\u207B')
print('K_I of 4-methylpyrazole inhib: '+str(np.round(K_I(K_m2,I1_conc),2))+' mM')
print('K_M of YqhD w/ propionaldehyde: '+str(np.round(K_m1,2))+' mM')
